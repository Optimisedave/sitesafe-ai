import { test, expect } from "@playwright/test";
import path from "path";

// Note: This test assumes the user is already logged in and has an active subscription.
// It requires mocking or handling the AI processing delay.

test.describe("File Upload and Report Generation Flow", () => {
  // Use a unique identifier for the test file to avoid conflicts
  const testFileName = `test-diary-${Date.now()}.txt`;
  const testFileContent = "Site Diary Entry - 02 May 2025\nWeather: Sunny\nActivities: Scaffold erection commenced. All workers attended safety briefing. Note: One section of scaffold appears slightly unstable, requires checking by supervisor. Potential hazard.";

  test.beforeEach(async ({ page }) => {
    // --- Authentication Placeholder --- 
    // In a real test suite, you would programmatically log in the user before each test.
    // This could involve:
    // 1. Reusing authentication state saved from a setup test (see https://playwright.dev/docs/auth)
    // 2. Making an API call to log in.
    // 3. Navigating through the UI login flow (less efficient).
    console.log("TEST INFO: Assuming user is logged in and subscribed for upload test.");
    // For scaffold purposes, we navigate directly to the dashboard.
    await page.goto("/app");
    await expect(page.locator("h1")).toContainText("Dashboard");
  });

  test("should allow file upload and display the generated report", async ({ page }) => {
    // 1. Prepare the test file locally (within the test execution context)
    // Playwright typically runs tests from the project root.
    // We need a way to provide the file content to the upload input.
    // Using setInputFiles with buffer content is a reliable way.
    const fileBuffer = Buffer.from(testFileContent, "utf-8");

    // 2. Locate the upload input/button and upload the file
    // The actual selector depends on how the upload component is implemented.
    // Assuming a standard <input type="file">, possibly hidden and triggered by a button.
    const fileInputSelector = "input[type=\"file\"]"; // Adjust if needed
    const uploadButtonSelector = "button:has-text(\"Upload New File\")"; // Adjust if needed

    // If the input is hidden, we might need to make it visible or use setInputFiles directly
    // For this example, let's assume the button triggers the input or we target the input directly.
    
    // Listen for the file chooser event *before* clicking the button if the input is hidden
    const fileChooserPromise = page.waitForEvent("filechooser");
    await page.locator(uploadButtonSelector).click();
    const fileChooser = await fileChooserPromise;
    await fileChooser.setFiles({ name: testFileName, mimeType: "text/plain", buffer: fileBuffer });

    // Alternatively, if the input is visible or targetable:
    // await page.locator(fileInputSelector).setInputFiles({ name: testFileName, mimeType: "text/plain", buffer: fileBuffer });

    // 3. Verify Upload Success (Optional: check for success message)
    // await expect(page.locator("text=Upload successful")).toBeVisible({ timeout: 10000 }); // Example

    // 4. Wait for AI Processing and Report Appearance
    // This is the tricky part. The report generation is asynchronous.
    // Strategies:
    // - Poll the dashboard UI for the new report title.
    // - Poll a specific API endpoint that indicates processing status.
    // - Use a longer timeout and wait for the element directly.
    
    console.log("TEST INFO: Waiting for report to appear on dashboard (may take time depending on processing)...");
    const reportTitle = `Report for ${testFileName}`; // Match the title format from the API
    const reportLinkSelector = `a:has-text("${reportTitle}")`;

    // Wait for the report link to appear on the dashboard, polling as needed
    await expect(page.locator(reportLinkSelector)).toBeVisible({ timeout: 60000 }); // Increased timeout for processing

    // 5. Navigate to the Report Page
    await page.locator(reportLinkSelector).click();
    await page.waitForURL(`**/app/report/**`);

    // 6. Verify Report Content
    await expect(page.locator("h1")).toContainText(reportTitle);
    // Check for content generated by the AI (based on placeholder logic)
    await expect(page.locator("article")).toContainText("Scaffold structure seems unstable"); // Check report body
    // Check for the risk flag in the sidebar
    await expect(page.locator("div:has-text(\"Risk Flags\") >> ..")).toContainText("Scaffold structure seems unstable");
    await expect(page.locator("div:has-text(\"Risk Flags\") >> ..")).toContainText("Severity: High"); // Assuming placeholder AI flags it as High

  });
});

